import argparse
import logging
import os.path
import threading
import time
import sys

from flask import Flask, request, abort, send_file, render_template, Response
from flask_cors import CORS

sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))  # two dir up is the root of the project
from PythonClient.multirotor.control.simulation_task_manager import SimulationTaskManager

if os.environ.get("IN_DOCKER", False):
    print("Running in docker")
else:
    print("Running locally")

# read command line arguments, if any
parser = argparse.ArgumentParser(description='AirSim Python Multirotor API Server')
parser.add_argument('--mode', default='SimpleFlight', help='Mode for the drone control, PX4 or SimpleFlight', required=False)
print("Mode: " + parser.parse_args().mode)

parser.add_argument('--ue_ip', default='localhost', help='IP address of the DRV UE5 game', required=False)
print("UE IP: " + parser.parse_args().ue_ip)


# if in docker, we need to set the environment variables

app = Flask(__name__, template_folder="./templates")

log = logging.getLogger('werkzeug')
log.setLevel(logging.ERROR)
CORS(app)

# initialize the task dispatcher based on the mode
task_dispatcher = SimulationTaskManager(parser.parse_args().mode)
threading.Thread(target=task_dispatcher.start).start()
task_number = 1


# For Frontend to fetch all missions available to use
# @app.route('/mission', methods=['GET'])
# def mission():
#     directory = '../multirotor/mission'
#     return [file for file in os.listdir(directory) if os.path.isfile(os.path.join(directory, file))]

@app.route('/google_api_key', methods=['GET'])
def get_google_api_key():
    return task_dispatcher.get_google_api_key()

@app.route('/addTask', methods=['POST'])
def add_task():
    global task_number
    uuid_string = time.strftime("%Y-%m-%d-%H-%M-%S", time.localtime()) + "_Batch_" + str(task_number)
    task_dispatcher.add_task(request.get_json(), uuid_string)
    task_number += 1
    print(f"New task added to queue, currently {task_dispatcher.mission_queue.qsize()} in queue")
    return uuid_string


@app.route('/currentRunning', methods=['GET'])
def get_current_running():
    return task_dispatcher.get_current_task_batch()


@app.route('/report')
@app.route('/report/<path:dir_name>')
def get_report(dir_name=''):
    report_root_dir = os.path.join(os.path.expanduser("~"), "Documents", "AirSim", "report")
    dir_path = os.path.join(report_root_dir, dir_name)
    if not os.path.exists(dir_path):
        return abort(404)
    if os.path.isfile(dir_path):
        return send_file(dir_path)
    files = os.listdir(dir_path)
    return render_template('files.html', files=files)


@app.route('/stream/<drone_name>/<camera_name>')
def stream(drone_name, camera_name):
    if task_dispatcher.unreal_state['state'] == 'idle':
        return "No task running"
    else:
        try:
            return Response(
                task_dispatcher.get_stream(drone_name, camera_name),
                mimetype='multipart/x-mixed-replace; boundary=frame'
            )
        except Exception as e:
            print(e)
            return "Error"


# @app.route('/uploadMission', methods=['POST'])
# def upload_file():
#     file = request.files['file']
#     filename = file.filename
#     custom_mission_dir = '../multirotor/mission/custom'
#     path = os.path.join(custom_mission_dir, filename)
#     file.save(path)
#     return 'File uploaded'


# def update_settings_json(drone_number, separation_distance):
#     SettingGenerator(drone_number, separation_distance)


@app.route('/state', methods=['GET'])
def get_state():
    """
    For unreal engine to check the current run state
    :return:  json obj consists of the current state with this specific format
    {
        "state": "idle"
    }
    or
    {
        "state": "start"
    }
    any other state will be not accepted by the unreal engine side and the change will be ignored
    """
    return task_dispatcher.unreal_state


@app.route('/cesiumCoordinate', methods=['GET'])
def get_map():
    return task_dispatcher.load_cesium_setting()


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
    # makes it discoverable by other devices in the network
